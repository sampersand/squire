renowned Value;

form Parser {
	matter stream, index;

	imitate(stream: Text) {
		soul.stream = stream;
		soul.index = I;
	}

	change is-eof() => soul.index > length(soul.stream);
	change peek() => soul.stream[soul.index];
	change advance
		() if soul.index > length(soul.stream) { catapult ğ”¢ğ”ªğ”­ğ”±ğ”µ ğ”°ğ”±ğ”¯ğ”¢ğ”ğ”ª },
		() => soul.index = soul.index + I

	change peek_advance() {
		nigh peeked = soul.peek();
		soul.advance();
		reward peeked;
	}

	change take_whilst(cond: Journey): Text {
		nigh acc = "";
		nigh chr;

		whilst !soul.is-eof() && cond(chr = soul.peek()) {
			acc = acc + chr;
			soul.advance();
		}

		reward acc;
	}

	change next(): Value {
		renowned Literal;
		renowned Variable;
		renowned Function;

		N.B. These are actually defined in the global scope.
		journey isdigit(c) => '0' <= c && c <= '9';
		journey islower(c) => ğ” <= c && c <= ğ”· || c == '_' || isdigit(c);
		journey isupper(c) => ğ”„ <= c && c <= â„¨ || c == '_';

		nigh chr;
		nigh func;

		fork (chr=soul.peek()) {
			path '#':
				soul.take_whilst(\(c) => c != "\n")
				rejoin; N.B. Ie fallthru

			path [' ', "\t", "\n", "\r", '(', ')', '[', ']', '{', '}', ':']:
				soul.advance();
				reward soul.next();

			path isdigit:
				reward Literal(numeral(soul.take_whilst(isdigit)))

			path islower:
				reward Variable.fetch(soul.take_whilst(islower))

			path ["'", '"']:
				renowned _quote = chr N.B. Noncapturing lambadas go brr
				soul.advance()
				nigh result = Literal(soul.take_whilst(\(c) => c != _quote));

				if soul.peek_advance() != chr {
					catapult ğ”ªğ”¦ğ”°ğ”°ğ”¦ğ”«ğ”¤ ğ” ğ”©ğ”¬ğ”°ğ”¦ğ”«ğ”¤ ğ”®ğ”²ğ”¬ğ”±ğ”¢;
				}

				reward result;

			path isupper:
				soul.take_whilst(isupper);
				fork chr {
					path ğ”—: reward Literal(yea)
					path ğ”‰: reward Literal(nay)
					path ğ”‘: reward Literal(ni)
				}

			done:
			alas:
				soul.advance();
				whence done;

				if ni == (func=Function.FUNCTIONS[chr]) {
					catapult ğ”²ğ”«ğ”¨ğ”«ğ”¬ğ”´ğ”« ğ”±ğ”¬ğ”¨ğ”¢ğ”« ğ”°ğ”±ğ”ğ”¯ğ”±\: + chr;
				}

				nigh args = [];
				nigh i = I;

				whilst i <= func.arity {
					insert(args, i, soul.next());
					i = i + I;
				}

				reward Function(func, args);
		}
	}
}
