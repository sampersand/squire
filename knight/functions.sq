form Function {
	matter func, args;

	change run() {
		nigh a = soul.args;

		fork a.length {
		path I:   reward (soul.func)(a[I])
		path II:  reward (soul.func)(a[I], a[II])
		path III: reward (soul.func)(a[I], a[II], a[III])
		alas: $bug("invalid arg length")
		}
	}
}

form AlwaysRunFunction {
	matter func, args;

	change run() {
		renowned run;
		nigh a = soul.args;

		fork a.length {
		path N:   reward (soul.func)()
		path I:   reward (soul.func)(run(a[I]))
		path II:  reward (soul.func)(run(a[I]), run(a[II]))
		path III: reward (soul.func)(run(a[I]), run(a[II]), run(a[III]))
		path IV:  reward (soul.func)(run(a[I]), run(a[II]), run(a[III]), run(a[IV]))
		alas: $bug("invalid arg length")
		}
	}
}


journey to numeral
	(x) => tally(x),
	(_) { catapult "TODO" } ;

journey to text
	(x: Book) => x,
	(x) => prose(x);

journey to book
	(_: nay)     => [],
	(x: yea | N) => [x],
	(x: Numeral) {
		nigh b = [];
		start:
		whilst x = x / X {
			whence start;
			b = [x % X] + b
		}
		reward b
	},
	(x) => book(x);

journey run
	(x: Numeral | Text | Veracity | ni | Book) => x,
	(other) => other.run();

journey dump-out
	(_: yea) => proclaimn(𝔱𝔯𝔲𝔢),
	(_: nay) => proclaimn(𝔣𝔞𝔩𝔰𝔢),
	(_: ni) => proclaimn(𝔫𝔲𝔩𝔩),
	(num: Numeral) => proclaimn(arabic(num)),
	(txt: Text) => proclaimn("\"{txt}\""), N.B. TODO
	(b: Book) {
		proclaimn('[');
		if b.length {
			nigh i = N;
			start:
			whilst i < b.length {
				proclaimn(', ');
				whence start;
				dump-out(b[i = i + I])
			}
		}
		proclaimn(']');
	};

journey cmp
	(x, y) => x <=> y,
	(*x) { catapult "TODO" };

journey eql(x,y) => x == y;

renowned not-always-run-functions = {
	'B': \(arg) => arg,
	'&': \(x, y) {
		nigh ran = run(x);
		if ran {
			reward run(y);
		} alas {
			reward x;
		}
	},
	'|': \(x, y) {
		nigh ran = run(x);
		if ran {
			reward x;
		} alas {
			reward run(y);
		}
	},
	'=': \(var, val) {
		var.assign(ran = run(val));
		reward ran;
	},
	'W': \(cond, body) {
		whilst run(cond) {
			run(body);
		}
		# IMPLICIT NI REWARD
	},
	'I': (\(cond, ift, iff) { catapult "TODO" }),
}

renowned always-run-functions = {
	# Nullary
	'R': \() => gamble() % 4294967295, N.B. Far too large to represent with roman numerals
	'P': \() => inquire(),

	# UNARY
	'C': \(arg) => run(run(arg)),
	'Q': \(arg) => dismount(arg),
	'D': \(val) {
		nigh ran;
		dump-out(ran = run(val))
		reward ran;
	},
	'O': \(x) { catapult "TODO" },
	'L': foo,
	'L': \(x) => to-book(x).length,
	'!': \(x) => !x,
	'~': \(x) => -tally(x),
	'A': \(x) { catapult "TODO" },
	',': \(x) => [x],
	'[': \(x) => to-book(x)[I],
	']': \(x) { catapult "TODO" },

	# BINARY
	'+': (journey	(x: Numeral, y) => x + tally(y),
						(x: Text, y)    => x + to-text(y),
						(x: Book, y)    => x + to book(y)),
	'-': \(x, y) => x - y,
	'*': \(x, y) => x * tally(y), N.B. LOL this happens to work for all the overrides
	'/': \(x, y) => x / y,
	'%': \(x, y) => x % y,
	'^': (journey	(x: Book, y) => x * to-text(y),
						(x, y) => x ^ y),
	'<': \(x, y) => cmp(x, y) < N,
	'>': \(x, y) => cmp(x, y) > N,
	'?': \(x, y) => eql(x, y),
	';': \(x, y) { run(x); reward run(y)},

	# TERNARY
	'G': \(coll, start, len) { catapult "TODO" },

	# QUATERNARY
	'S': \(coll, start, len, repl) { catapult "TODO" }
};
