form Function {
	matter func, args;

	change run() {
		nigh a = soul.args;

		fork a.length {
		path I:   reward (soul.func)(a[I])
		path II:  reward (soul.func)(a[I], a[II])
		path III: reward (soul.func)(a[I], a[II], a[III])
		alas: $bug("invalid arg length")
		}
	}
}

form AlwaysRunFunction {
	matter func, args;

	change run() {
		renowned run;
		nigh a = soul.args;

		fork a.length {
		path N:   reward (soul.func)()
		path I:   reward (soul.func)(run(a[I]))
		path II:  reward (soul.func)(run(a[I]), run(a[II]))
		path III: reward (soul.func)(run(a[I]), run(a[II]), run(a[III]))
		path IV:  reward (soul.func)(run(a[I]), run(a[II]), run(a[III]), run(a[IV]))
		alas: $bug("invalid arg length")
		}
	}
}

journey join (ary: [], sep) => '', (ary, sep) {
	renowned to-text
	nigh result = to-text(ary.verso)
	nigh i = II;
	whilst i <= ary.length {
		result = result + sep + to-text(ary[i])
		i = i + I
	}
	reward result
}

journey to numeral
	(x) => tally(x),
	(_) { catapult "TODO" } ;

journey to text
	(x: Numeral) => arabic(x),
	(x: yea) => 'true',
	(x: nay) => 'false',
	(x: ni) => '',
	(x: Book) => join(x, "\n"),
	(x) => prose(x);

journey to book
	(_: nay)     => [],
	(x: yea | N) => [x],
	(x: Numeral) {
		nigh b = [];
		start:
		whilst x = x / X {
			whence start;
			b = [x % X] + b
		}
		reward b
	},
	(x) => book(x);

journey run
	(x: Numeral | Text | Veracity | ni | Book) => x,
	(other) => other.run();

journey dump-out
	(_: yea) => proclaimn(ð”±ð”¯ð”²ð”¢),
	(_: nay) => proclaimn(ð”£ð”žð”©ð”°ð”¢),
	(_: ni) => proclaimn(ð”«ð”²ð”©ð”©),
	(num: Numeral) => proclaimn(arabic(num)),
	(txt: Text) => proclaimn("\"{txt}\""), N.B. TODO
	(b: \(x) => x == []) => proclaimn('[]'), N.B. Cant use `[]` directly because its overloaded as old syntax for `|`
	(b: Book) {
		proclaimn('[');
		nigh i = N;
		start:
		whilst i < b.length {
			proclaimn(', ');
			whence start;
			dump-out(b[i = i + I])
		}
		proclaimn(']');
	},
	(other) {
		dump(other)
		dismount(0)
	};

journey cmp
	(x: Veracity, y) => tally(x) <=> tally(veracity(y)),
	(x: Book, y) {
		y = to-book(y);
		nigh min = x.length
		if min > y { min = y.length }
		nigh i = N
		whilst (i = i + I) <= min {
			nigh c
			if c = cmp(x[i], y[i]) {
				reward c
			}
		}
		reward x.length <=> y.length;
	},
	(x: Numeral, y) => x <=> tally(y),
	(x: Text, y) => x <=> to-text(y);

journey eql(x,y) => x == y;

renowned not-always-run-functions = {
	'B': \(arg) => arg,
	'&': (journey	(x, y) if !(x=run(x)) => x,
						(x, y) => run(y)),
	'|': (journey	(x, y) if veracity(x=run(x)) => x,
						(x, y) => run(y)),
	'=': \(var, val) {
		var.assign(ran = run(val));
		reward ran;
	},
	'W': \(cond, body) {
		whilst run(cond) {
			run(body);
		}
		# IMPLICIT NI REWARD
	},
	'I': (\(cond, ift, iff) { catapult "TODO" }),
}

renowned always-run-functions = {
	# Nullary
	'R': \() => gamble() % 4294967295, N.B. Far too large to represent with roman numerals
	'P': \() => inquire(),

	# UNARY
	'C': \(arg) => run(arg),
	'Q': \(arg) => dismount(arg),
	'D': \(val) {
		nigh ran;
		dump-out(ran = val)
		reward ran;
	},
	'O': \(x) {
		nigh str = to-text(x);
		if str.length && substr(str, str.length, I) == '\\' {
			proclaimn(substr(str, I, str.length - I))
		} alas {
			proclaim(str)
		}
	},
	'L': \(x) => to-book(x).length,
	'!': \(x) => !x,
	'~': \(x) => -tally(x),
	'A': \(x) => ascii(x),
	',': \(x) => [x],
	'[': \(x) => to-book(x)[I],
	']': \(x) { catapult "TODO" },

	# BINARY
	'+': (journey	(x: Numeral, y) => x + tally(y),
						(x: Text, y)    => x + to-text(y),
						(x: Book, y)    => x + to book(y)),
	'-': \(x, y) => x - y,
	'*': \(x, y) => x * tally(y), N.B. LOL this happens to work for all the overrides
	'/': \(x, y) => x / y,
	'%': \(x, y) => x % y,
	'^': (journey	(x: Book, y) => join(x, to-text(y)),
						(x, y) => x ^ y),
	'<': \(x, y) => cmp(x, y) < N,
	'>': \(x, y) => cmp(x, y) > N,
	'?': \(x, y) => eql(x, y),
	';': \(x, y) => y,

	# TERNARY
	'G': \(coll, start, len) { catapult "TODO" },

	# QUATERNARY
	'S': \(coll, start, len, repl) { catapult "TODO" }
};
